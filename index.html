<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Генератор цветовых палитр</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        :root {
            --bg-light: #f8f9fa;
            --bg-dark: #1a1a1a;
            --text-light: #333;
            --text-dark: #f0f0f0;
            --card-light: #ffffff;
            --card-dark: #2d2d2d;
            --primary: #4361ee;
            --primary-hover: #3a56d4;
            --success: #06d6a0;
            --border-radius: 12px;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            --shadow-dark: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        body {
            transition: background-color 0.3s, color 0.3s;
            min-height: 100vh;
            padding: 20px;
        }

        .light-theme {
            background-color: var(--bg-light);
            color: var(--text-light);
        }

        .dark-theme {
            background-color: var(--bg-dark);
            color: var(--text-dark);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding: 20px;
            border-radius: var(--border-radius);
            background-color: var(--card-light);
            box-shadow: var(--shadow);
        }

        .dark-theme header {
            background-color: var(--card-dark);
            box-shadow: var(--shadow-dark);
        }

        h1 {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary);
        }

        .theme-toggle {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: inherit;
            padding: 8px;
            border-radius: 50%;
            transition: background-color 0.2s;
        }

        .theme-toggle:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .dark-theme .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 40px;
            padding: 24px;
            border-radius: var(--border-radius);
            background-color: var(--card-light);
            box-shadow: var(--shadow);
        }

        .dark-theme .controls {
            background-color: var(--card-dark);
            box-shadow: var(--shadow-dark);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: transparent;
            color: inherit;
            border: 2px solid var(--primary);
        }

        .btn-secondary:hover {
            background-color: rgba(67, 97, 238, 0.1);
        }

        .btn-icon {
            padding: 10px;
            min-width: 44px;
            justify-content: center;
        }

        .options {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            margin-left: auto;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            font-size: 14px;
        }

        select, input[type="range"] {
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid #ccc;
            background-color: white;
            font-size: 16px;
        }

        .dark-theme select, .dark-theme input[type="range"] {
            border-color: #555;
            background-color: #333;
            color: white;
        }

        input[type="range"] {
            width: 200px;
        }

        .palette-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 40px;
        }

        .palette {
            display: flex;
            height: 180px;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .color-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, filter 0.2s;
        }

        .color-card:hover {
            transform: translateY(-4px);
            filter: brightness(1.05);
            z-index: 1;
        }

        .color-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .color-hex {
            font-size: 18px;
            font-weight: 700;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            color: #333;
        }

        .dark-theme .color-hex {
            background-color: rgba(0, 0, 0, 0.7);
            color: #f0f0f0;
        }

        .color-actions {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
            color: #333;
        }

        .action-btn:hover {
            transform: scale(1.1);
            background-color: white;
        }

        .dark-theme .action-btn {
            background-color: rgba(0, 0, 0, 0.7);
            color: #f0f0f0;
        }

        .pinned {
            background-color: gold !important;
            color: #333 !important;
        }

        .footer {
            text-align: center;
            padding: 20px;
            font-size: 14px;
            color: #666;
            border-top: 1px solid #eee;
            margin-top: 40px;
        }

        .dark-theme .footer {
            color: #aaa;
            border-top-color: #444;
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 16px 24px;
            background-color: var(--success);
            color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(20px); }
            15% { opacity: 1; transform: translateY(0); }
            85% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(20px); }
        }

        .mockup {
            margin-top: 40px;
            padding: 30px;
            border-radius: var(--border-radius);
            background-color: var(--card-light);
            box-shadow: var(--shadow);
        }

        .dark-theme .mockup {
            background-color: var(--card-dark);
            box-shadow: var(--shadow-dark);
        }

        .mockup-title {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--primary);
        }

        .mockup-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .mockup-button {
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            border: none;
            cursor: default;
        }

        .mockup-card {
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            width: 200px;
        }

        .color-count {
            font-size: 14px;
            margin-left: 10px;
            color: #666;
        }

        .dark-theme .color-count {
            color: #aaa;
        }

        .color-preview {
            width: 100%;
            height: 60px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .palette {
                flex-direction: column;
                height: auto;
            }
            
            .color-card {
                height: 120px;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .options {
                margin-left: 0;
                width: 100%;
            }
        }
    </style>
</head>
<body class="light-theme">
    <div id="app" class="container">
        <header>
            <h1><i class="fas fa-palette"></i> Генератор цветовых палитр</h1>
            <button class="theme-toggle" @click="toggleTheme">
                <i :class="darkTheme ? 'fas fa-sun' : 'fas fa-moon'"></i>
            </button>
        </header>

        <div class="controls">
            <button class="btn btn-primary" @click="generatePalette">
                <i class="fas fa-random"></i> Случайная палитра
            </button>
            
            <button class="btn btn-secondary" @click="resetPalette">
                <i class="fas fa-redo"></i> Сбросить
            </button>
            
            <div class="options">
                <div class="option-group">
                    <label for="colorCount">Цветов в палитре: <span class="color-count">{{ colorCount }}</span></label>
                    <input type="range" id="colorCount" v-model="colorCount" min="3" max="7" step="2">
                </div>
                
                <div class="option-group">
                    <label for="colorFormat">Формат цвета:</label>
                    <select id="colorFormat" v-model="colorFormat">
                        <option value="hex">HEX</option>
                        <option value="rgb">RGB</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="palette-container">
            <div class="palette">
                <div 
                    class="color-card" 
                    v-for="(color, index) in palette" 
                    :key="index"
                    :style="{ backgroundColor: color.hex }"
                    @click="copyToClipboard(color)"
                >
                    <div class="color-info">
                        <div class="color-hex">{{ colorFormat === 'hex' ? color.hex : color.rgb }}</div>
                        <div class="color-actions">
                            <button 
                                class="action-btn" 
                                :class="{ pinned: color.pinned }"
                                @click.stop="togglePin(color)"
                                :title="color.pinned ? 'Открепить цвет' : 'Закрепить цвет'"
                            >
                                <i class="fas fa-thumbtack"></i>
                            </button>
                            <button 
                                class="action-btn" 
                                @click.stop="regenerateColor(index)"
                                title="Сгенерировать новый цвет"
                            >
                                <i class="fas fa-sync-alt"></i>
                            </button>
                        </div>
                    </div>
                    <div class="color-preview"></div>
                </div>
            </div>
        </div>

        <div class="mockup">
            <h2 class="mockup-title">Превью палитры в интерфейсе</h2>
            <div class="mockup-content">
                <div class="mockup-button" :style="{ backgroundColor: palette[0]?.hex || '#4361ee', color: getContrastColor(palette[0]?.hex || '#4361ee') }">
                    Пример кнопки
                </div>
                <div class="mockup-card" :style="{ backgroundColor: palette[1]?.hex || '#f8f9fa', color: getContrastColor(palette[1]?.hex || '#f8f9fa') }">
                    <h3>Заголовок карточки</h3>
                    <p>Текст карточки с примером контента для тестирования читаемости.</p>
                </div>
                <div class="mockup-card" :style="{ backgroundColor: palette[2]?.hex || '#ffffff', color: getContrastColor(palette[2]?.hex || '#ffffff'), border: '1px solid #eee' }">
                    <h3>Ещё одна карточка</h3>
                    <p>Другой пример использования цветов из палитры.</p>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Практика 27: Генератор цветовых палитр. Закреплённые цвета сохраняются между перезагрузками.</p>
        </div>

        <div v-if="showNotification" class="notification">
            <i class="fas fa-check-circle"></i> Скопировано: {{ copiedColor }}
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, watch } = Vue;

        createApp({
            setup() {
                const darkTheme = ref(false);
                const colorCount = ref(5);
                const colorFormat = ref('hex');
                const palette = ref([]);
                const showNotification = ref(false);
                const copiedColor = ref('');
                const generateRandomColor = () => {
                    const letters = '0123456789ABCDEF';
                    let color = '#';
                    for (let i = 0; i < 6; i++) {
                        color += letters[Math.floor(Math.random() * 16)];
                    }
                    return color;
                };
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? 
                        `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : 
                        '';
                };
      
                const generateHarmoniousPalette = () => {
                    const baseHue = Math.floor(Math.random() * 360);
                    const newPalette = [];
                    
                    for (let i = 0; i < colorCount.value; i++) {
                        if (palette.value[i] && palette.value[i].pinned) {
                            newPalette.push(palette.value[i]);
                            continue;
                        }
 
                        const hue = (baseHue + (i * 360 / colorCount.value)) % 360;
                        const saturation = 50 + Math.random() * 40;
                        const lightness = 40 + Math.random() * 30;
       
                        const hslToHex = (h, s, l) => {
                            l /= 100;
                            const a = s * Math.min(l, 1 - l) / 100;
                            const f = n => {
                                const k = (n + h / 30) % 12;
                                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                                return Math.round(255 * color).toString(16).padStart(2, '0');
                            };
                            return `#${f(0)}${f(8)}${f(4)}`;
                        };
                        
                        const hex = hslToHex(hue, saturation, lightness);
                        const rgb = hexToRgb(hex);
                        
                        newPalette.push({
                            hex,
                            rgb,
                            pinned: false
                        });
                    }
                    
                    return newPalette;
                };
           
                const generatePalette = () => {
                    const newPalette = generateHarmoniousPalette();
                    
                    palette.value.forEach((color, index) => {
                        if (color.pinned && newPalette[index]) {
                            newPalette[index] = { ...color };
                        }
                    });
                    
                    palette.value = newPalette;
                    saveToLocalStorage();
                };
 
                const regenerateColor = (index) => {
                    if (palette.value[index].pinned) return;
                    
                    const newColor = generateRandomColor();
                    const rgb = hexToRgb(newColor);
                    
                    palette.value[index] = {
                        hex: newColor,
                        rgb,
                        pinned: false
                    };
                    
                    saveToLocalStorage();
                };
     
                const copyToClipboard = async (color) => {
                    const textToCopy = colorFormat.value === 'hex' ? color.hex : color.rgb;
                    
                    try {
                        await navigator.clipboard.writeText(textToCopy);
                        copiedColor.value = textToCopy;
                        showNotification.value = true;
                        
                        setTimeout(() => {
                            showNotification.value = false;
                        }, 3000);
                    } catch (err) {
                        console.error('Ошибка копирования: ', err);
                        // Fallback для старых браузеров
                        const textArea = document.createElement('textarea');
                        textArea.value = textToCopy;
                        document.body.appendChild(textArea);
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        
                        copiedColor.value = textToCopy;
                        showNotification.value = true;
                        
                        setTimeout(() => {
                            showNotification.value = false;
                        }, 3000);
                    }
                };
              
                const togglePin = (color) => {
                    color.pinned = !color.pinned;
                    saveToLocalStorage();
                };
                
                const resetPalette = () => {
                    palette.value = palette.value.map(color => ({
                        ...color,
                        pinned: false
                    }));
                    generatePalette();
                };
    
                const toggleTheme = () => {
                    darkTheme.value = !darkTheme.value;
                    document.body.classList.toggle('light-theme');
                    document.body.classList.toggle('dark-theme');
                    localStorage.setItem('colorPaletteTheme', darkTheme.value ? 'dark' : 'light');
                };
                
                const getContrastColor = (hexColor) => {
                    if (!hexColor) return '#333';
       
                    const hex = hexColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                    return brightness > 128 ? '#333' : '#f0f0f0';
                };
                

                const saveToLocalStorage = () => {
                    const data = {
                        palette: palette.value,
                        colorCount: colorCount.value,
                        colorFormat: colorFormat.value
                    };
                    localStorage.setItem('colorPaletteData', JSON.stringify(data));
                };

                const loadFromLocalStorage = () => {
                    const savedData = localStorage.getItem('colorPaletteData');
                    const savedTheme = localStorage.getItem('colorPaletteTheme');
                    
                    if (savedTheme === 'dark') {
                        darkTheme.value = true;
                        document.body.classList.remove('light-theme');
                        document.body.classList.add('dark-theme');
                    }
                    
                    if (savedData) {
                        const data = JSON.parse(savedData);
                        colorCount.value = data.colorCount || 5;
                        colorFormat.value = data.colorFormat || 'hex';
                        
                        if (data.palette && data.palette.length > 0) {
                            palette.value = data.palette;
                            
                            
                            if (palette.value.length !== colorCount.value) {
                                if (palette.value.length > colorCount.value) {
                                    palette.value = palette.value.slice(0, colorCount.value);
                                } else {
                                    const neededColors = colorCount.value - palette.value.length;
                                    for (let i = 0; i < neededColors; i++) {
                                        const hex = generateRandomColor();
                                        palette.value.push({
                                            hex,
                                            rgb: hexToRgb(hex),
                                            pinned: false
                                        });
                                    }
                                }
                            }
                            return;
                        }
                    }
                    
    
                    generatePalette();
                };
              
                watch(colorCount, (newVal, oldVal) => {
                    if (newVal !== oldVal) {
                        if (newVal > oldVal) {
                            // Добавляем новые цвета
                            const neededColors = newVal - oldVal;
                            for (let i = 0; i < neededColors; i++) {
                                const hex = generateRandomColor();
                                palette.value.push({
                                    hex,
                                    rgb: hexToRgb(hex),
                                    pinned: false
                                });
                            }
                        } else {
                            const pinnedIndices = [];
                            palette.value.forEach((color, index) => {
                                if (color.pinned) pinnedIndices.push(index);
                            });
                            
                            const newPalette = palette.value.filter((color, index) => {
                                if (color.pinned) return true;
                                return index < newVal;
                            });
                            
                            pinnedIndices.forEach(index => {
                                if (index < newVal && !newPalette.some(c => c === palette.value[index])) {
                                    newPalette.splice(index, 0, palette.value[index]);
                                }
                            });
                            
                            palette.value = newPalette.slice(0, newVal);
                        }
                        
                        saveToLocalStorage();
                    }
                });
                
                watch(colorFormat, () => {
                    saveToLocalStorage();
                });
                
                watch(palette, () => {
                    saveToLocalStorage();
                }, { deep: true });
                
                onMounted(() => {
                    loadFromLocalStorage();
                });
                
                return {
                    darkTheme,
                    colorCount,
                    colorFormat,
                    palette,
                    showNotification,
                    copiedColor,
                    generatePalette,
                    regenerateColor,
                    copyToClipboard,
                    togglePin,
                    resetPalette,
                    toggleTheme,
                    getContrastColor
                };
            }
        }).mount('#app');
    </script>
</body>
</html>